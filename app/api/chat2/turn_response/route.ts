import { CHAT2_SYSTEM_PROMPT, getChat2StateContext, Chat2ConversationState, ConversationPhase, getNextPhase, phaseValidators } from "@/config/chat2-constants";
import OpenAI from "openai";
import { NextResponse } from "next/server";

// Language detection from user message
function detectLanguage(text: string): 'turkish' | 'english' {
  const turkishChars = /[√ßƒüƒ±√∂≈ü√º√áƒûIƒ∞√ñ≈û√ú]/;
  const turkishWords = ['√ºr√ºn', '√ºlke', 'ben', 'merhaba', 'te≈üekk√ºr', 'satƒ±≈ü', 'ihracat'];
  const englishWords = ['product', 'country', 'hello', 'thank', 'export', 'sales'];
  
  const textLower = text.toLowerCase();
  
  if (turkishChars.test(text)) return 'turkish';
  
  for (const word of turkishWords) {
    if (textLower.includes(word)) return 'turkish';
  }
  
  for (const word of englishWords) {
    if (textLower.includes(word)) return 'english';
  }
  
  return 'turkish'; // Default to Turkish
}

// Extract data from AI response and current phase
function extractDataFromResponse(
  response: string, 
  phase: ConversationPhase,
  userMessage: string
): Partial<Chat2ConversationState['data']> {
  const updates: Partial<Chat2ConversationState['data']> = {};
  
  switch (phase) {
    case ConversationPhase.PRODUCT:
      // For product phase, use the user message directly
      if (userMessage.trim()) {
        updates.product = userMessage.trim();
      }
      break;
      
    case ConversationPhase.COUNTRY:
      // For country phase, use the user message directly
      if (userMessage.trim()) {
        updates.country = userMessage.trim();
      }
      break;
      
    case ConversationPhase.GTIP_CODE:
      // Check if user knows GTIP code or not
      const knowsGtip = userMessage.toLowerCase().includes('evet') || 
                       userMessage.toLowerCase().includes('biliyorum') ||
                       userMessage.toLowerCase().includes('yes');
      
      if (knowsGtip && userMessage.match(/\d{6,}/)) {
        // Extract GTIP code from user message
        const gtipMatch = userMessage.match(/\d{6,}/);
        if (gtipMatch) {
          updates.gtipCode = gtipMatch[0].substring(0, 6);
        }
      } else if (!knowsGtip) {
        // User doesn't know, we'll suggest one
        updates.gtipCode = '-'; // Will be updated if user accepts suggestion
      }
      break;
      
    case ConversationPhase.SALES_CHANNELS:
      // Extract sales channels from user message
      updates.salesChannels = [userMessage.trim()];
      break;
      
    case ConversationPhase.WEBSITE:
      // Extract website or mark as not provided
      if (userMessage.toLowerCase().includes('yok') || 
          userMessage.toLowerCase().includes('hayƒ±r') ||
          userMessage.toLowerCase().includes('no')) {
        updates.website = '-';
      } else {
        updates.website = userMessage.trim();
      }
      break;
      
    case ConversationPhase.NAME:
      updates.name = userMessage.trim();
      break;
      
    case ConversationPhase.EMAIL:
      // Email validation happens in validator
      updates.email = userMessage.trim();
      break;
      
    case ConversationPhase.PHONE:
      updates.phone = userMessage.trim();
      break;
      
    case ConversationPhase.KEYWORDS:
      // Keywords are generated by AI, not from user input
      // Mark as confirmed regardless of user response
      break;
      
    case ConversationPhase.COMPETITORS:
      // Competitors are found by AI, not from user input
      break;
      
    case ConversationPhase.CUSTOMERS:
      // Customers are found by AI, not from user input
      break;
  }
  
  return updates;
}

export async function POST(req: Request) {
  try {
    console.log('üì• Chat2 API: Request received');
    
    const { messages, conversationState } = await req.json();
    
    console.log('üìù Messages count:', messages?.length);
    console.log('üîÑ Current state:', conversationState);
    
    if (!messages || messages.length === 0) {
      console.error('‚ùå No messages provided');
      return NextResponse.json(
        { error: 'No messages provided' },
        { status: 400 }
      );
    }
    
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    
    // Detect language from first user message if not already detected
    let updatedState = { ...conversationState };
    if (messages.length > 1 && messages[1].role === 'user' && updatedState.language === 'turkish') {
      const detectedLang = detectLanguage(messages[1].content);
      updatedState.language = detectedLang;
      console.log('üåç Language detected:', detectedLang);
    }
    
    // Get the last user message
    const lastUserMessage = messages.filter((m: any) => m.role === 'user').pop();
    const userInput = lastUserMessage?.content || '';
    console.log('üí¨ User input:', userInput);
    
    // Extract data from user message based on current phase
    const dataUpdates = extractDataFromResponse(
      '', 
      updatedState.currentPhase,
      userInput
    );
    
    console.log('üìä Data updates:', dataUpdates);
    
    // Validate the input for current phase
    const validator = phaseValidators[updatedState.currentPhase as keyof typeof phaseValidators];
    const isValid = validator ? validator(userInput) : true;
    console.log('‚úÖ Validation result:', isValid);
    
    // Update state if validation passes
    if (isValid && Object.keys(dataUpdates).length > 0) {
      const updatedData = { ...updatedState.data, ...dataUpdates };
      const updatedPhaseCompleted = { ...updatedState.phaseCompleted, [updatedState.currentPhase]: true };
      
      // Special handling for phases that should immediately advance
      const autoAdvancePhases = [
        ConversationPhase.KEYWORDS,
        ConversationPhase.COMPETITORS,
        ConversationPhase.CUSTOMERS
      ];
      
      let newPhase = updatedState.currentPhase;
      if (!autoAdvancePhases.includes(updatedState.currentPhase)) {
        newPhase = getNextPhase(updatedState.currentPhase);
        console.log('‚è≠Ô∏è  Advanced to phase:', ConversationPhase[newPhase]);
      }
      
      updatedState = {
        ...updatedState,
        data: updatedData,
        phaseCompleted: updatedPhaseCompleted,
        currentPhase: newPhase
      };
    }
    
    // Prepare context for AI
    const stateContext = getChat2StateContext(updatedState);
    
    console.log('ü§ñ Calling OpenAI API...');
    
    // Call OpenAI with simplified system
    const completion = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: CHAT2_SYSTEM_PROMPT + "\n\n" + stateContext
        },
        ...messages
      ],
      temperature: 0.3, // Lower temperature for more deterministic responses
      max_tokens: 1000,
    });
    
    console.log('‚úÖ OpenAI response received');
    
    const response = completion.choices[0].message;
    
    // Handle tool calls if any
    const finalContent = response.content || '';
    
    if (response.tool_calls && response.tool_calls.length > 0) {
      // Process tool calls here if needed
      // For now, we'll just acknowledge them
      console.log('üîß Tool calls detected:', response.tool_calls.length);
      
      // Special handling for phases that need tool results
      if (updatedState.currentPhase === ConversationPhase.COMPETITORS ||
          updatedState.currentPhase === ConversationPhase.CUSTOMERS) {
        // After showing competitors/customers, advance phase
        updatedState.currentPhase = getNextPhase(updatedState.currentPhase);
      }
    }
    
    // Special handling for keyword confirmation
    if (updatedState.currentPhase === ConversationPhase.KEYWORDS && 
        messages.length > 0 && 
        messages[messages.length - 1].role === 'user') {
      // User responded to keywords, advance to competitors
      updatedState.currentPhase = ConversationPhase.COMPETITORS;
    }
    
    console.log('üì§ Sending response');
    
    return NextResponse.json({
      message: finalContent,
      conversationState: updatedState,
      debug: {
        currentPhase: ConversationPhase[updatedState.currentPhase],
        phaseNumber: updatedState.currentPhase,
        collectedData: updatedState.data,
        language: updatedState.language
      }
    });
    
  } catch (error: any) {
    console.error('‚ùå Chat2 API Error:', error);
    console.error('‚ùå Error message:', error?.message);
    console.error('‚ùå Error stack:', error?.stack);
    
    return NextResponse.json(
      { 
        error: 'Internal server error',
        message: error?.message || 'Unknown error',
        details: process.env.NODE_ENV === 'development' ? error?.stack : undefined
      },
      { status: 500 }
    );
  }
}
